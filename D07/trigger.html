<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">


 <title>PL/SQL: Triggers</title>

</head>


<body>
 
<h2>Triggers</h2>


Triggers are similar to procedures and functions, but triggers are executed implicitly whenever the triggering event
happens, and they don't accept arguments. The act of executing a trigger is known as <i>firing</i> the trigger. The
triggering event event can be:
<ul>
 <li> a DML operation on a database or certain kinds of view
 </li><li> some DDL operations (such as table creation)
 </li><li> some system operations like (a DB startup or shutdown)
</li></ul>
<p>
Using triggers we can
</p><ul>
 <li> maintain a complex integrity constraints not possible through declarative constraints enabled at table creation;
 </li><li> audit information in a table by recording the changes made and who made them;
 </li><li> automatically signal other programs that action needs to take place when changes are made to a table;
 </li><li> publish information about various events in a publish-subscribe environment.
</li></ul>


<h3>Creating triggers</h3>
The general syntax to create a trigger is
<pre class="syntax"><b>create</b> [<b>or replace</b>] <b>trigger</b> trigger_name
 {<b>before</b> | <b>after</b> | <b>instead of</b>} triggering_event
 [referencing_clause]
 [<b>when</b> trigger_condition]
 [<b>for each row</b>]
 trigger_body;
</pre>


<h4>Creating DML triggers</h4>
A DML trigger is fired on an <kbd>insert</kbd>, <kbd>update</kbd>, or <kbd>delete</kbd> operations on a database. It can
be fired before or after the statement executes, and can be fired once per row, or once per statement. The table below
summarizes the various options:
<table cellspacing="0">
 <tbody><tr>
  <th align="left">Category</th>
  <th align="left">Values</th>
  <th align="left">Comments</th>
 </tr>
 <tr>
  <td class="row">Statement&nbsp;&nbsp;</td>
  <td class="row"><nobr><kbd>insert</kbd>, <kbd>update</kbd>, or <kbd>delete</kbd></nobr>&nbsp;&nbsp;</td>
  <td class="row">Defines which kind of DML statement causes the trigger to fire.</td>
 </tr>
 <tr>
  <td class="row">Timing</td>
  <td class="row"><kbd>before</kbd> or <kbd>after</kbd></td>
  <td class="row">Defines whether the trigger fires before or after the statement is executed.</td>
 </tr>
 <tr>
  <td class="lastrow">Level</td>
  <td class="lastrow">row or statement</td>
  <td class="lastrow">If the trigger is a row-level trigger, it fires once for each row affected by the triggering statement.
      If the trigger is a statement-level trigger, it fires once, either before or after the statement. A row-level triggers
	  are identified by the <kbd><b>for each row</b></kbd> clause.</td>
 </tr>
</tbody></table>


<h4><kbd><b>instead of</b></kbd> triggers</h4>
Oracle 8<i>i</i> (and higher) provides an additional kind of trigger. <kbd><b>instead of</b></kbd> trigger can be defined
on views only. Unlike DML triggers, which execute in addition to the DML operation, an instead-of trigger will execute
<i>instead</i> of the DML statement that fired it. Instead-of trigger must be row-level. These triggers are useful in
situations when we need to insert into a join view. It's illegal to <kbd>insert</kbd> into a view which is a join view
of two or more tables and insert requires that both underlying tables were modified. Instead we can use an instead-of
trigger on the <kbd>insert</kbd> event on that view and modify the underlying tables separately.




<h4>Order of DML trigger firing</h4>
Triggers are fired as the DML statement is executed. The algorithm for executing a DML statement is given here:
<ol>
 <li> Execute the <kbd>before</kbd> statement-level triggers, if present.
 </li><li> For each row affected by the statement:
  <ol>
   <li> Execute the <kbd>before</kbd> row-level triggers, if present.
   </li><li> Execute the statement itself.
   </li><li> Execute the <kbd>after</kbd> row-level triggers, if present.
  </li></ol>
 </li><li> Execute the <kbd>after</kbd> statement-level triggers, if present.
</li></ol>
A <a href="https://web.archive.org/web/20110809071133/http://ist.marshall.edu/ist480adbp/code/firingOrder.sql">very good example</a> from Scott Urman's <i>PL/SQL Programming</i> illustrates this
algorithm.


<h4>Correlation identifiers in row-level triggers</h4>
Inside a row-level trigger (which executes once per row processed by the triggering statement) we can access the data
in the row that is currently being processed. This is accomplished through two correlation identifiers -
<kbd><b>:old</b></kbd> and <kbd><b>:new</b></kbd>. The colon in front of each indicates that they re bind variables and not
regular PL/SQL variables. The PL/SQL compiler treats them as records of type
<kbd><b><i>triggering_table</i>%rowtype</b></kbd>,
where the <i>triggering table</i> is the table for which the trigger is defined. Thus, the reference such as
<kbd>:new.field</kbd> will be valid only if there is a column <i>field</i> in the triggering table. The meanings of
<kbd>:old</kbd> and <kbd>:new</kbd> are explained in the table:
<table cellspacing="0">
<tbody><tr><th align="left">Statement&nbsp;&nbsp;</th><th align="left"><kbd>:old</kbd></th><th align="left"><kbd>:new</kbd></th></tr>
<tr>
 <td class="row"><kbd>insert</kbd></td>
 <td class="row">undefined - all fields are <kbd>NULL</kbd></td>
 <td class="row">Values that will be inserted when the statement is complete</td>
</tr>
<tr>
 <td class="row"><kbd>update</kbd></td>
 <td class="row">Original values for the row before the update</td>
 <td class="row">New values that will be updated when the statement is complete</td>
</tr>
<tr>
 <td class="lastrow"><kbd>delete</kbd></td>
 <td class="lastrow">Original values before the row is deleted</td>
 <td class="lastrow">undefined - all fields are <kbd>NULL</kbd></td>
</tr>
</tbody></table>


<p>If desired, we can use the <i>referencing</i> clause to specify a different name for <kbd>:old</kbd> and <kbd>:new</kbd>.
This clause has the following syntax:
</p><pre class="syntax"><b>referencing</b> [<b>old as</b> <i>old_name</i>] [<b>new as</b> <i>new_name</i>]
</pre>
For example,
<pre class="example"><b>create or replace trigger</b> GenerateProfID
 <b>before insert on</b> Professors
 <b>referencing new as</b> new_prof
 <b>for each row</b>
<b>begin</b>
  <b>if</b> :new_prof.pid <b>is null then</b>
    select profids.nextval into :new_prof.pid from dual;
  <b>end if</b>;
<b>end</b> GenerateProfID;
</pre>


<h3>The <kbd>when</kbd> clause</h3>
The <kbd><b>when</b></kbd> clause is valid for row-level triggers only. If present, the trigger body will be executed
only for those rows that meet the condition specified. The syntax of the <kbd>when</kbd> clause is
<pre class="syntax"><b>when</b> trigger_condition
</pre>
where <i>trigger_condition</i> is a Boolean expression. The <kbd>:new</kbd> and <kbd>:old</kbd> records can be
referenced inside the expression, but like <kbd>referencing</kbd>, the colon is <i>not</i> used there.
In the following example the trigger will be executed only for 'DB' department:
<pre class="example"><b>create trigger</b> InsertStudent
 <b>after insert or update on</b> Student
 <b>for each row</b>
 <b>when</b> (new.mid = 'DB')
<b>begin</b>
  /* <i>put code here</i> */
<b>end</b> InsertStudent;
</pre>

<h3>Trigger predicates</h3>
If we use one trigger that can be fired by several statements (for example, <kbd>insert</kbd> and <kbd>update</kbd>),
we may need to find out inside the trigger which statement fired the trigger. Oracle provides three Boolean
functions that we can use to determine this. These functions are:
<ul>
 <li> <kbd><b>inserting</b></kbd> - is <kbd>true</kbd> if the triggering statement is <kbd>insert</kbd>;
      <kbd>false</kbd> otherwise.
 </li><li> <kbd><b>updating</b></kbd> - is <kbd>true</kbd> if the triggering statement is <kbd>update</kbd>;
      <kbd>false</kbd> otherwise.
 </li><li> <kbd><b>deleting</b></kbd> - is <kbd>true</kbd> if the triggering statement is <kbd>delete</kbd>;
      <kbd>false</kbd> otherwise.
</li></ul>


<h3>System triggers</h3>
System triggers, unlike DML triggers, are fired on two different kind of events: DDL or database. DDL events include:
<kbd>create</kbd>, <kbd>alter</kbd>, or <kbd>drop</kbd> statements, whereas database events include startup/shutdown
of the server, logon/logof of a user, and a server error. The general syntax for creating a system trigger is
<pre class="syntax"><b>create</b> [<b>or replace</b>] <b>trigger</b> [schema.]trigger_name
  { <b>before</b> | <b>after</b> }
  { DDL_event_list | DB_event_list}
  <b>on</b> { <b>database</b> | [schema.]<b>schema</b> }
  [<b>when</b> condition]
  trigger_body
</pre>

<table cellpadding="3" cellspacing="0" border="0">
<tbody><tr>
 <th align="left">Event</th>
 <th align="left">Timing allowed</th>
 <th align="left">Description</th>
</tr>
<tr>
 <td><kbd>startup</kbd></td>
 <td><kbd>after</kbd></td>
 <td>Fired when an instance is started up.</td>
</tr>
<tr>
 <td><kbd>shutdown</kbd></td>
 <td><kbd>before</kbd></td>
 <td>Fired when an instance is shut down. This trigger may not fire if the DB is shutdown abnormally.</td>
</tr>
<tr>
 <td><kbd>servererror&nbsp;&nbsp;</kbd></td>
 <td><kbd>after</kbd></td>
 <td>Fired whenever an error occurs.</td>
</tr>
<tr>
 <td><kbd>logon</kbd></td>
 <td><kbd>after</kbd></td>
 <td>Fired after a user has successfully connected to the database.</td>
</tr>
<tr>
 <td><kbd>logoff</kbd></td>
 <td><kbd>before</kbd></td>
 <td>Fired at the start of the logoff.</td>
</tr>
<tr>
 <td><kbd>create</kbd></td>
 <td><kbd>before, after&nbsp;</kbd></td>
 <td>Fired before or after a schema object is created.</td>
</tr>
<tr>
 <td><kbd>drop</kbd></td>
 <td><kbd>before, after&nbsp;</kbd></td>
 <td>Fired before or after a schema object is dropped.</td>
</tr>
<tr>
 <td class="lastrow"><kbd>alter</kbd></td>
 <td class="lastrow"><kbd>before, after</kbd></td>
 <td class="lastrow">Fired before or after a schema object is altered.</td>
</tr>
</tbody></table>

<p>
A system trigger can be defined at the database level trigger or a schema level trigger (keywords <kbd><b>database</b></kbd>
and <kbd><b>schema</b></kbd>). A database-level trigger will fire whenever the triggering event occurs, whereas a
schema-level trigger will fire only when the triggering event occurs for the specified schema. If the schema name is not
specified with the <kbd>schema</kbd> keyword, it defaults to the schema that owns the trigger.
The following trigger monitors all logons to the current schema
</p><pre class="example"><b>create or replace trigger</b> MonitorLogons
  <b>after logon on schema</b>
<b>begin</b>
  <b>insert into</b> danil.logons <b>values</b> (<b>user</b>, <b>sysdate</b>);
<b>end</b> MonitorLogons;
</pre>
This trigger will monitor only the connections to the schema that owns this trigger, but if we change the keyword
<kbd>schema</kbd> to <kbd>database</kbd> we will monitor all connections to the database. Don't forget that
all users have to have the <kbd>insert</kbd> privilege on the table used in the trigger and also the person who creates
the trigger should have enough privileges to do so.
Please see more detailed example <a href="https://web.archive.org/web/20110809071133/http://ist.marshall.edu/ist480adbp/code/DatabaseSchema.sql">here</a>. Please also read
<a href="https://web.archive.org/web/20110809071133/http://download-west.oracle.com/docs/cd/B10501_01/server.920/a96524/c11schem.htm#31717">this chapter</a>
from Oracle documentation to better understand the difference between schema and database.

<p>
<table cellpadding="2" cellspacing="0">
<caption align="bottom"><b>System privileges related to triggers</b></caption>
<tbody><tr> <th>Privilege</th> <th>Description</th></tr>
<tr>
 <td><kbd>create trigger</kbd></td>
 <td>Allows the grantee to create a trigger in his or her own schema.</td>
</tr>
<tr>
 <td><kbd>create any trigger</kbd></td>
 <td>Allows the grantee to create triggers in any schema except <kbd>SYS</kbd>.</td>
</tr>
<tr>
 <td><kbd>alter any trigger</kbd></td>
 <td>Allows the grantee to enable, disable, or compile database triggers in any schema except <kbd>SYS</kbd>.</td>
</tr>
<tr>
 <td><kbd>drop any trigger</kbd></td>
 <td>Allows the grantee to drop database triggers in any schema except <kbd>SYS</kbd>.</td>
</tr>
<tr>
 <td class="lastrow"><kbd>administer database trigger</kbd></td>
 <td class="lastrow">Allows the grantee to create or alter a system trigger on the database. The grantee must also have either
  <kbd>create trigger</kbd> or <kbd>create any trigger</kbd> privilege.
 </td>
</tr>
</tbody></table>

</p><h4>Event attribute function</h4>
There are several event attribute functions that allow in system trigger body to get information about the triggering event.
We already saw trigger predicates (<kbd>inserting</kbd>, <kbd>deleteing</kbd>, <kbd>updating</kbd>). These functions work
similar to these, but may return string or number values not only boolean. Unlike these trigger predicates, event
attribute functions are stand-alone PL/SQL functions that are owned by <kbd><b>SYS</b></kbd>. There are no synonyms defined
for them by default, so they must be prefixed by <kbd>sys.</kbd> in order to resolve them.

<table cellpadding="1" cellspacing="0">
<caption align="bottom"><b>Event attribute functions</b></caption>
<tbody><tr>
 <th align="left">Function</th>
 <th align="left">Datatype</th>
 <th align="left">Event applicable for</th>
 <th align="left">Description</th>
</tr>
<tr>
 <td class="row"><kbd>sysevent</kbd></td>
 <td class="row"><kbd>varchar2(20)</kbd></td>
 <td class="row">All events</td>
 <td class="row">Returns the system event that fired the trigger</td>
</tr>
<tr>
 <td class="row"><kbd>instance_num</kbd></td>
 <td class="row"><kbd>number</kbd></td>
 <td class="row">All events</td>
 <td class="row">Returns the current instance number. This will always be 1 unless you are running with Oracle Real Application Cluster</td>
</tr>
<tr>
 <td class="row"><kbd>database_name</kbd></td>
 <td class="row"><kbd>varchar2(50)</kbd></td>
 <td class="row">All events</td>
 <td class="row">Returns the current database name.</td>
</tr>
<tr>
 <td class="row"><kbd>server_error</kbd></td>
 <td class="row"><kbd>number</kbd></td>
 <td class="row"><kbd>servererror</kbd></td>
 <td class="row">Takes a single <kbd>number</kbd> argument. Returns the error at the position on the error stack indicated by the argument. The position 1 is the top of the stack.</td>
</tr>
<tr>
 <td class="row"><kbd>is_servererror</kbd></td>
 <td class="row"><kbd>boolean</kbd></td>
 <td class="row"><kbd>servererror</kbd></td>
 <td class="row">Takes an error number as an argument, and returns <kbd>true</kbd> if the Oracle indicated is on the error stack.</td>
</tr>
<tr>
 <td class="row"><kbd>login_user</kbd></td>
 <td class="row"><kbd>varchar2(30)</kbd></td>
 <td class="row">All events</td>
 <td class="row">Returns the user ID of the user that fired the trigger.</td>
</tr>
<tr>
 <td class="row"><kbd>dictionary_obj_type</kbd></td>
 <td class="row"><kbd>varchar2(20)</kbd></td>
 <td class="row"><kbd>create, alter, drop</kbd></td>
 <td class="row">Returns the type of the dictionary object on which the DDL operation that fired the trigger occurred.</td>
</tr>
<tr>
 <td class="row"><kbd>dictionary_obj_name</kbd></td>
 <td class="row"><kbd>varchar2(30)</kbd></td>
 <td class="row"><kbd>create, alter, drop</kbd></td>
 <td class="row">Returns the name of the dictionary object on which the DDL operation that fired the trigger occurred.</td>
</tr>
<tr>
 <td class="row"><kbd>dictionary_obj_owner</kbd></td>
 <td class="row"><kbd>varchar2(30)</kbd></td>
 <td class="row"><kbd>create, alter, drop</kbd></td>
 <td class="row">Returns the owner of the dictionary object on which the DDL operation that fired the trigger occurred.</td>
</tr>
<tr>
 <td class="row"><kbd>des_encrypted_password</kbd>&nbsp;&nbsp;</td>
 <td class="row"><nobr><kbd>varchar2(30)</kbd></nobr>&nbsp;&nbsp;</td>
 <td class="row"><kbd>create</kbd> or <kbd>alter</kbd> user</td>
 <td class="row">Returns the DES encrypted password of the user being created or altered.</td>
</tr>
</tbody></table>

The following example illustrates how to use these functions. In this example we create a trigger that monitors all
<kbd>create</kbd> operations against a database. If such an operation happens, the trigger check what kind of object was
created. If the created object is a user object, then information about who and when created a new user as well as
new user ID is inserted into the table <i>example.new_users</i>
<pre class="example"><b>create or replace trigger</b> MonitorCreation
 <b>after create on database</b>
<b>declare</b>
  msg TestCreateTrig.event%<b>type</b>;
<b>begin</b>
  <b>if</b> <b>sys.dictionary_obj_type</b> = 'USER' <b>then</b>
    msg := 'User ' || <b>sys.login_user</b>;
    msg := msg || ' created user ' || <b>sys.dictionary_obj_name</b>;
	msg := msg || ' identified by ' || <b>sys.des_encrypted_password</b>;
    <b>insert into</b> system.TestCreateTrig <b>values</b> (<b>user</b>, <b>sysdate</b>, msg);
  <b>end if</b>;
<b>end</b> MonitorCreation;
</pre>

<h4>Restrictions on triggers</h4>
The body of the trigger is a PL/SQL block. That is, any statement legal in PL/SQL block is legal in a trigger body, with
the following restrictions apply:
<ul>
 <li> A trigger may not issue any <a href="https://web.archive.org/web/20110809071133/http://ist.marshall.edu/ist480adbp/plsql_trnctl.html" style="text-decoration:none; color:black; font-weight:bold;">transaction control statements</a>.
 </li><li> That also means that any procedure or a function called in the body of the trigger may not issue any transaction
      control statements.
 </li><li> The trigger body cannot declare <kbd>long</kbd> or <kbd>long raw</kbd> variables. Also, <kbd>:new</kbd> and
      <kbd>:old</kbd> variables cannot refer to a <kbd>long</kbd> or <kbd>long raw</kbd> columns in the table for which
	  trigger is defined.
 </li><li> In Oracle8 and higher, code in a trigger body may reference and use <kbd>lob</kbd> columns, but it may not modify the
      values of the columns.
</li></ul>

<br>
Just like DML triggers, system triggers may use th e<kbd>when</kbd> clause to specify a condition on the trigger firing.
However, there are restrictions on the type of conditions that may be specified for each type of system trigger namely:
<ul>
 <li> <kbd>startup</kbd> and <kbd>shutdown</kbd> triggers cannot have any conditions
 </li><li> <kbd>servererror</kbd> triggers can use <kbd>errno</kbd> test to check for a specific error only
 </li><li> <kbd>logon</kbd> and <kbd>logoff</kbd> triggers can check the user ID or username with the <kbd>userid</kbd>
      or <kbd>username</kbd> tests
 </li><li> DDL triggers can check the type and name of the object being modified, and can check the useris or user name
</li></ul>

<h4>Other trigger issues</h4>
Once a trigger created, its source code and all other information about the trigger is stored into the system dictionary
table <kbd><b>all_triggers</b></kbd>. Also there is the view <kbd><b>user_triggers</b></kbd> based on that table that
shows all information about the current user triggers.

<p>
To drop a trigger user needs to execute the following command:
</p><pre class="syntax"><b>drop trigger</b> <i>trigger_name</i>;
</pre>
This command permanently removes the trigger from the data dictionary. Of course, the user has to have enough privileges to
successfully execute this command.
Unlike procedures and packages, a trigger may be disabled without removing it. If a trigger is disables it still is in the
data dictionary, but it cannot be fired. To disable a trigger, a user should execute the comand
<pre class="syntax"><b>alter trigger</b> <i>trigger_name</i> <b>disable</b>;
</pre>
To enable the trigger back use
<pre class="syntax"><b>alter trigger</b> <i>trigger_name</i> <b>enable</b>;
</pre>
All triggers for a particular table can be enable or disable with one <kbd>alter table</kbd> command:
<pre class="syntax"><b>alter table</b> <i>table_name</i>  {<b>disable</b> | <b>enable</b>} <b>all triggers</b>;
</pre>





</body></html>
